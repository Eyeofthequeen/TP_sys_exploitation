//#########################################################
//#
//# Titre : 	TP3
//#
//# Auteur : 	Miriam Davydov et Harvé Leka
//#	Date :	21 décembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "client.h"
#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include <string.h>

struct noeud* head; // Pointeur de tête de liste
struct noeud* queue; // Pointeur de queue de liste pour ajout rapide
int nbVM, nbThreadAELX; // nombre de VM actives et nombre de threads actifs A E L X

sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

void initialisation() {
	head = NULL;
	queue = NULL;
	nbVM = 0;
	nbThreadAELX = 0;

	sem_init(&semH, 0, 1);
	sem_init(&semQ, 0, 1);
	sem_init(&semnbVM, 0, 1);
	sem_init(&semC, 0, 1);
	sem_init(&semnbThreadAELX, 0, 1);
}

int main()
{
    int server_socket_fd, client_socket_fd, client_size;

    struct sockaddr_in client_address;
    struct sockaddr_in server_address;
    struct transaction_info transaction_info;
    
    initialisation();

    server_socket_fd = socket(AF_INET, SOCK_STREAM, 0);
    
    if(server_socket_fd == -1) {
		printf("Socked creation failed...\n");
		exit(0);
    } else {
		printf("Socked successfully created...\n");
    }

    server_address.sin_family = AF_INET;
    server_address.sin_addr.s_addr = inet_addr(LOCALHOST);
    server_address.sin_port = PORT;
    
    setsockopt(server_socket_fd, SOL_SOCKET, SO_REUSEADDR, (struct sockaddr *)&client_address, sizeof(client_address));
    if ((bind(server_socket_fd, (struct sockaddr *)&server_address, sizeof(server_address))) != 0) {
		printf("Socket bind failed...\n");
		exit(0);
    } else {
		printf("Socket successfully binded... \n");
    } 

    listen(server_socket_fd, MAX_CONNECTION_ATTEMPTS); // Server is ready to listen

    while (1)
    {
        client_size = sizeof(client_address);
        client_socket_fd = accept(server_socket_fd, (struct sockaddr *)&client_address, &client_size);
        if (client_socket_fd < 0) {
				printf("Server accept failed...\n");
				exit(0);
        } else {
        		printf("Server accept the client...\n");

        		read(client_socket_fd, &transaction_info, sizeof(transaction_info));

        		// Interpret transaction and return response
        		strcpy(transaction_info.response, readTrans(transaction_info.transaction));
        		printf("Server is responding...\n");
				
        		write(client_socket_fd, transaction_info.response, sizeof(transaction_info.response));
        }
        
        close(client_socket_fd);
    }
}