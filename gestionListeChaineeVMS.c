//#########################################################
//#
//# Titre : 	Utilitaires Liste Chainee et CVS LINUX Automne 21
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#            VERSION CONCURRENTE
//#
//# Auteur : 	Francois Meunier
//#	Date :		Novembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"

//Pointeur de tête de liste
extern struct noeudVM* head;
//Pointeur de queue de liste pour ajout rapide
extern struct noeudVM* queue;
// nombre de VM actives
extern int nbVM;
// nombre de threads actifs
extern int nbThreadAELX;

//semaphores pour pointeur de tete et pointeur de queue, nbVM, nbThreadALX et la console

extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

//#######################################
//# Recherche un item dans la liste chaînée
//# ENTREE: Numéro de la ligne
//# RETOUR:	Un pointeur vers l'item recherché		
//# 		Retourne NULL dans le cas où l'item
//#			est introuvable
//#
struct noeudVM * findItem(const int no){
	
	//La liste est vide 
	//verrouiller pointeur de tete et pointeur de queue
   sem_wait(&semH);
   sem_wait(&semQ);
   
	if ((head==NULL)&&(queue==NULL)) {
		// deverrouiller pointeur de tete et pointeur de queue
		sem_post(&semQ);
		sem_post(&semH);
		return NULL;
	}
	
	
	//Pointeur de navigation
	
	//verrouiller noeud de tete
	sem_wait(&head->semNoeud); 
	struct noeudVM * ptr = head;
	sem_post(&semQ);
	sem_post(&semH);

	if(ptr->VM.noVM==no) // premier noeudVM
		return ptr; // retourner le noeud de tete verrouille
		
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	}
	else{ // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		
		sem_post(&(optr->semNoeud)); 

		//Est-ce l'item recherché?
		if (ptr->VM.noVM==no){
			return ptr; // retourner le noeud verrouille
		}
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud));
		}
		else{ // ptr->suivant==NULL no invalide
			sem_post(&(ptr->semNoeud)); // deverrouille dernier noeud verrouille
		}
	}
	//On retourne un pointeur NULL
	return NULL;
}

//#######################################
//#
//# Recherche le PRÉDÉCESSEUR d'un item dans la liste chaînée
//# ENTREE: Numéro de la ligne a supprimer
//# RETOUR:	Le pointeur vers le prédécesseur est retourné		
//# 		Retourne NULL dans le cas où l'item est introuvable
//#
struct noeudVM * findPrev(const int no){
	
	//La liste est vide 
	//verrouiller pointeur de tete et pointeur de queue
   sem_wait(&semH);
   sem_wait(&semQ);
   
	if ((head==NULL)&&(queue==NULL)) {
		// deverrouiller pointeur de tete et pointeur de queue
		sem_post(&semQ);
		sem_post(&semH);
		return NULL;
	}
	
	//verrouiller premier noeud
	sem_wait(&(head->semNoeud)); 
	
	//Pointeur de navigation
	struct noeudVM * ptr = head;
	// deverrouiller pointeur de tete et pointeur de queue
	sem_post(&semQ);
	sem_post(&semH);
	
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	}
	else{ // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}
	
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){
		//Est-ce le prédécesseur de l'item recherché?
		if (ptr->suivant->VM.noVM==no){
			//Deverouiller le noeud suivant
			sem_post(&(ptr->suivant->semNoeud));
			
			//On retourne un pointeur sur l'item précédent
			//Retourne le noeud verrouille
			return ptr;
		}
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		sem_post(&(optr->semNoeud)); 
		
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
		}
		else{ // ptr->suivant==NULL no invalide
			sem_post(&(ptr->semNoeud)); // deverrouille noeud courant
		}
	}
	//On retourne un pointeur NULL
	return NULL;
	}

//#####################################################
//# Ajoute un item a la fin de la liste chaînée de VM
//# ENTREE: 
//#	RETOUR:  
void addItem(void * param){
	sem_wait(&semnbThreadAELX);
	    nbThreadAELX++;
	sem_post(&semnbThreadAELX);
	
	//Création de l'enregistrement en mémoire
	struct noeudVM* ni = (struct noeudVM*)malloc(sizeof(struct noeudVM));
//printf("\n noVM=%d busy=%d adr ni=%p", ni->VM.noVM, ni->VM.busy, ni);
//printf("\n noVM=%d busy=%d adrQ deb=%p", ni->VM.noVM, ni->VM.busy,queue);

	//Affectation des valeurs des champs
	ni->VM.noVM	= ++nbVM;
	//printf("\n noVM=%d", ni->VM.noVM);
	ni->VM.busy	= 0;
	//printf("\n busy=%d", ni->VM.busy);
	ni->VM.ptrDebutVM	= (unsigned short*)malloc(sizeof(unsigned short)*65536);
//printf("\n noVM=%d busy=%d adrptr VM=%p", ni->VM.noVM, ni->VM.busy, ni->VM.ptrDebutVM);
//printf("\n noVM=%d busy=%d adrQ=%p", ni->VM.noVM, ni->VM.busy, queue);	

	// Semaphore pour le nouveau noeud
	sem_init(&(ni->semNoeud),0,1);
	
	//verrouiller pointeur de tete et pointeur de queue
   sem_wait(&semH);
   sem_wait(&semQ);	
     
   
	if ((head == NULL) && (queue == NULL)){//liste vide
		ni->suivant= NULL;
		queue = head = ni;
	  // deverrouiller pointeur de tete et pointeur de queue
		sem_post(&semQ);
		sem_post(&semH);
		sem_wait(&semnbThreadAELX);
	     nbThreadAELX--;
		sem_post(&semnbThreadAELX);
	  pthread_exit(0);
	}
	
	sem_wait(&(queue->semNoeud));	// verrouillage du noeud de queue
	
	// deverrouiller pointeur de tete
	sem_post(&semH);
	
	
	struct noeudVM* tptr = queue;
	ni->suivant= NULL;
	queue = ni;
//printf("\n noVM=%d busy=%d adrQ=%p", ni->VM.noVM, ni->VM.busy, queue);	
	tptr->suivant = ni;
//printf("\n noVM=%d busy=%d adr Queue=%p", ni->VM.noVM, ni->VM.busy,queue);

	sem_post(&(tptr->semNoeud));

	// deverrouiller pointeur de queue (avant)
	sem_post(&semQ);
	sem_wait(&semnbThreadAELX);
	    nbThreadAELX--;
	sem_post(&semnbThreadAELX);
}

//#######################################
//# Retire un item de la liste chaînée
//# ENTREE: noVM: numéro du noeud a retirer 
void removeItem(struct paramE* param){
	int noVM = param->noVM;
	free(param);
	struct noeudVM * ptr;
	struct noeudVM * tptr;
	struct noeudVM * optr;
	
	 // Attendre la terminaison des threads A E L et X  
    while(1) 
    {     
        sem_wait(&semnbThreadAELX);
        
        if(nbThreadAELX == 0)
        {
            break;
        }
        sem_post(&semnbThreadAELX);	
    }	

   
	//Vérification sommaire (noVM>0 et liste non vide)	aucune suppression
	if ((noVM<1)||((head==NULL)&&(queue==NULL))) {
		sem_post(&semnbThreadAELX);
		pthread_exit(0);
	}
		
	//Pointeur de recherche
	if(noVM==1){
		ptr = head;
		// suppression du premier element de la liste
		//Le noeud head reste verrouille
	}
	else{
		ptr = findItem(noVM-1); //Si ptr ! NULL, noeud previous deja verrouille
	}
	
	
	//L'item a été trouvé
	if (ptr!=NULL){
		sem_post(&(ptr->semNoeud)); // deverrouillage du noeud pas necessaire d'etre verrouille
		nbVM--;

		if((head == ptr) && (noVM==1)) // suppression de l'element de tete
		{
			if(head==queue) // un seul element dans la liste
			{
				// Detruire le semaphore correspondant au noeud
				sem_destroy(&(ptr->semNoeud));
				free(ptr->VM.ptrDebutVM);
				free(ptr);
				queue = head = NULL;
				
				sem_post(&semnbThreadAELX);
				pthread_exit(0);
			}
			tptr = ptr->suivant;
			head = tptr;		
			// Detruire le semaphore correspondant au noeud
			sem_destroy(&(ptr->semNoeud));
			free(ptr->VM.ptrDebutVM);
			free(ptr);		
		}
		else if (queue==ptr->suivant) // suppression de l'element de queue
		{
			queue=ptr;
			// Detruire le semaphore correspondant au queue
			sem_destroy(&(ptr->suivant->semNoeud));
			free(ptr->suivant->VM.ptrDebutVM);
			free(ptr->suivant);
			ptr->suivant=NULL;
						
			sem_post(&semnbThreadAELX);	
			pthread_exit(0);
		}
		else // suppression d'un element dans la liste
		{
			optr = ptr->suivant;	// optr pointe sur noeud a supprimer 
			ptr->suivant = ptr->suivant->suivant;
			tptr = ptr->suivant;
			
			// Detruire le semaphore correspondant au noeud
			sem_destroy(&(optr->semNoeud));	
			free(optr->VM.ptrDebutVM);
			free(optr);		
		}
		
		
		while (tptr!=NULL){ // ajustement des numeros de VM
		//Ajustement du noVM
			tptr->VM.noVM--;		
		//Déplacement du pointeur de navigation
			tptr=tptr->suivant;
		}
		sem_post(&semnbThreadAELX);
	}
	else {
		sem_post(&semnbThreadAELX);
	}	
}

//#######################################
//#
//# Affiche les items dont le numéro séquentiel est compris dans une plage
//#
void listItems(struct paramL* param){
	
	int start = param->nstart;
	int end = param->nend;
	free(param);
	sem_wait(&semnbThreadAELX);
	    nbThreadAELX++;
	sem_post(&semnbThreadAELX);
	//Verrouiller la console
   sem_wait(&semC);
   //Verrouiller le pointeur de tete
   sem_wait(&semH);
   
	//Affichage des entêtes de colonnes
	printf("noVM  Busy?		Adresse Debut VM                        \n");
	printf("========================================================\n");

	struct noeudVM * ptr = head;			//premier element
	//Verrouiller le noeud de tete
	sem_wait(&(ptr->semNoeud));
	//Deverrouiller le pointeur de tete
	sem_post(&semH);

	while (ptr!=NULL){

		//L'item a un numéro séquentiel dans l'interval défini
		if ((ptr->VM.noVM>=start)&&(ptr->VM.noVM<=end)){
			
			printf("%d \t %d \t %p\n",
				ptr->VM.noVM,
				ptr->VM.busy, ptr->VM.ptrDebutVM);
				
			
			}
		if (ptr->VM.noVM>end){
			//L'ensemble des items potentiels sont maintenant passés
			//Déplacement immédiatement à la FIN de la liste
			//Notez que le pointeur optr est toujours valide
			ptr=NULL;
			sem_post(&(ptr->semNoeud));
			}
		else{
			struct noeudVM* optr = ptr;
			if (ptr->suivant!=NULL) {
				sem_wait(&(ptr->suivant->semNoeud));
			}
			ptr = ptr->suivant;
			sem_post(&(optr->semNoeud)); 
			
		}

	}

	//Affichage des pieds de colonnes
	printf("========================================================\n\n");
	
	// Deverrouiller la console
	sem_post(&semC);	
	sem_wait(&semnbThreadAELX);
	    nbThreadAELX--;
	sem_post(&semnbThreadAELX);
			
}
