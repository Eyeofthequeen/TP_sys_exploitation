//#########################################################
//#
//# Titre : 	Utilitaires Liste Chainee et CVS LINUX Automne 21
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#            VERSION CONCURRENTE
//#
//# Auteur : 	Francois Meunier
//#	Date :		Novembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"

extern struct noeudVM* head;
extern struct noeudVM* queue;
extern int nbThreadAELX, nbVM;
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

void verrouillerSemaphoresQetH() {
	//verrouiller pointeur de tete et pointeur de queue
	sem_wait(&semH);
   sem_wait(&semQ);
}

void deverrouillerSemaphoresQetH() {
	// deverrouiller pointeur de tete et pointeur de queue
	sem_post(&semQ);
	sem_post(&semH);
}

void decrementerAELX() {
	sem_wait(&semnbThreadAELX);
	nbThreadAELX--;
	sem_post(&semnbThreadAELX);
}

void incrementerAELX() {
	sem_wait(&semnbThreadAELX);
	nbThreadAELX++;
	sem_post(&semnbThreadAELX);
}

void incrementerNbVM() {
	sem_wait(&semnbVM);
	nbVM++;
	sem_post(&semnbVM);
}

void decrementerNbVM(){
	sem_wait(&semnbVM);
	nbVM--;
	sem_post(&semnbVM);
}

struct noeudVM * findItem(const int no){
   verrouillerSemaphoresQetH();
   
	if (head == NULL && queue == NULL) { // Liste est vide
		deverrouillerSemaphoresQetH();
		return NULL;
	}
	
	//verrouiller noeud de tete
	sem_wait(&head->semNoeud); //verrouiller noeud de tete
	struct noeudVM * ptr = head;
	deverrouillerSemaphoresQetH();

	if(ptr->VM.noVM==no) // premier noeudVM
		return ptr; // retourner le noeud de tete verrouille
		
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	} else { // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}

	while (ptr->suivant!=NULL){
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr = ptr->suivant;
		sem_post(&(optr->semNoeud)); 

		//Est-ce l'item recherché?
		if (ptr->VM.noVM==no){
			return ptr; // retourner le noeud verrouille
		}
		
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud));
		} else {
			sem_post(&(ptr->semNoeud)); // deverrouille dernier noeud verrouille
		}
	}
	//On retourne un pointeur NULL
	return NULL;
}

struct noeudVM * findPrev(const int no){
   verrouillerSemaphoresQetH();
   
	if (head == NULL && queue == NULL) {
		deverrouillerSemaphoresQetH();
		return NULL;
	}
	
	sem_wait(&(head->semNoeud)); // verrouiller premier noeud
	
	struct noeudVM * ptr = head;
	deverrouillerSemaphoresQetH();
	
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	}
	else{ // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}
	
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){
		//Est-ce le prédécesseur de l'item recherché?
		if (ptr->suivant->VM.noVM==no){
			//Deverouiller le noeud suivant
			sem_post(&(ptr->suivant->semNoeud));
			
			//On retourne un pointeur sur l'item précédent
			//Retourne le noeud verrouille
			return ptr;
		}
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		sem_post(&(optr->semNoeud)); 
		
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
		}
		else{ // ptr->suivant==NULL no invalide
			sem_post(&(ptr->semNoeud)); // deverrouille noeud courant
		}
	}
	//On retourne un pointeur NULL
	return NULL;
	}

void addItem(struct paramA* param){
	WINDOW * serveur = param->serveur;
	free(param);

	incrementerAELX();
	
	//Création de l'enregistrement en mémoire
	struct noeudVM* ni = (struct noeudVM*)malloc(sizeof(struct noeudVM));
	incrementerNbVM();
	ni->VM.noVM	= nbVM;
	ni->VM.busy	= 0;
	ni->VM.ptrDebutVM	= (unsigned short*)malloc(sizeof(unsigned short)*65536);

	sem_init(&(ni->semNoeud),0,1); // Semaphore pour le nouveau noeud
	
   verrouillerSemaphoresQetH();
     
	if (head == NULL && queue == NULL){//liste vide
		ni->suivant = NULL;
		queue = head = ni;

		deverrouillerSemaphoresQetH();
		decrementerAELX();

		mvwprintw(serveur, 6, 2, "VM %d has been added with success.", nbVM);
	  	pthread_exit(0);
	}
	
	sem_wait(&(queue->semNoeud));	// verrouillage du noeud de queue	
	sem_post(&semH);
	
	struct noeudVM* tptr = queue;
	ni->suivant = NULL;
	queue = ni;	
	tptr->suivant = ni;

	sem_post(&(tptr->semNoeud));

	sem_post(&semQ);
	decrementerAELX();

	mvwprintw(serveur, 6, 2, "VM %d has been added with success.", nbVM);
}

void removeItem(struct paramE* param){
	int noVM = param->noVM;
	free(param);
	struct noeudVM * ptr;
	struct noeudVM * tptr;
	struct noeudVM * optr;
	
	 // Attendre la terminaison des threads A E L et X  
    while(1) 
    {     
        sem_wait(&semnbThreadAELX);
        
        if(nbThreadAELX == 0)
        {
            break;
        }
        sem_post(&semnbThreadAELX);	
    }	
   
	//Vérification sommaire (noVM>0 et liste non vide)	aucune suppression
	if ((noVM<1)||((head==NULL)&&(queue==NULL))) {
		sem_post(&semnbThreadAELX);
		pthread_exit(0);
	}
		
	//Pointeur de recherche
	if(noVM==1){
		ptr = head;
		// suppression du premier element de la liste
		//Le noeud head reste verrouille
	} else {
		ptr = findItem(noVM-1); //Si ptr ! NULL, noeud previous deja verrouille
	}
	
	//L'item a été trouvé
	if (ptr!=NULL){
		sem_post(&(ptr->semNoeud)); // deverrouillage du noeud pas necessaire d'etre verrouille
		decrementerNbVM();

		if((head == ptr) && (noVM==1)) // suppression de l'element de tete
		{
			if(head == queue) // un seul element dans la liste
			{
				sem_destroy(&(ptr->semNoeud));
				free(ptr->VM.ptrDebutVM);
				free(ptr);
				queue = head = NULL;
				
				sem_post(&semnbThreadAELX);
				pthread_exit(0);
			}
			tptr = ptr->suivant;
			head = tptr;		
			sem_destroy(&(ptr->semNoeud));
			free(ptr->VM.ptrDebutVM);
			free(ptr);		
		}
		else if (queue==ptr->suivant) // suppression de l'element de queue
		{
			queue = ptr;
			sem_destroy(&(ptr->suivant->semNoeud));
			free(ptr->suivant->VM.ptrDebutVM);
			free(ptr->suivant);
			ptr->suivant=NULL;
						
			sem_post(&semnbThreadAELX);	
			pthread_exit(0);
		} else { // suppression d'un element dans la liste
			optr = ptr->suivant;	// optr pointe sur noeud a supprimer 
			ptr->suivant = ptr->suivant->suivant;
			tptr = ptr->suivant;
			
			sem_destroy(&(optr->semNoeud));	
			free(optr->VM.ptrDebutVM);
			free(optr);		
		}
		
		while (tptr!=NULL){ // ajustement des numeros de VM
			tptr->VM.noVM--;		
			tptr=tptr->suivant;
		}
		sem_post(&semnbThreadAELX);
	}
	else {
		sem_post(&semnbThreadAELX);
	}	
}

void listItems(struct paramL* param){
	int start = param->nstart;
	int end = param->nend;
	WINDOW * serveur = param->serveur;
	free(param);
	
	incrementerAELX();
   sem_wait(&semC); // Verrouiller la console
   sem_wait(&semH);
	
	mvwprintw(serveur, 6, 2, "%s", "noVM  Busy? \t Adresse Debut VM                        ");
	mvwprintw(serveur, 7, 2, "%s", "========================================================");

	struct noeudVM * ptr = head;
	//Verrouiller le noeud de tete
	if (head != NULL) { sem_wait(&(ptr->semNoeud)); } // Verrouiller le noeud s'il existe
	sem_post(&semH); //Deverrouiller le pointeur de tete

	int line = 7;
	while (ptr!=NULL){
		//L'item a un numéro séquentiel dans l'interval défini
		if ((ptr->VM.noVM>=start)&&(ptr->VM.noVM<=end)){
			mvwprintw(serveur, ++line, 2, "%d \t %d \t %p\n", ptr->VM.noVM, ptr->VM.busy, ptr->VM.ptrDebutVM);
		}
			
		if (ptr->VM.noVM>end){
			//L'ensemble des items potentiels sont maintenant passés
			//Déplacement immédiatement à la FIN de la liste
			//Notez que le pointeur optr est toujours valide
			ptr=NULL;
			sem_post(&(ptr->semNoeud));
		} else {
			struct noeudVM* optr = ptr;
			if (ptr->suivant!=NULL) {
				sem_wait(&(ptr->suivant->semNoeud));
			}
			ptr = ptr->suivant;
			sem_post(&(optr->semNoeud)); 
		}
	}

	mvwprintw(serveur, ++line, 2, "%s", "========================================================");
	
	// Deverrouiller la console
	sem_post(&semC);	
	decrementerAELX();
}
