//#########################################################
//#
//# Titre : 	TP3
//#
//# Auteur : 	Miriam Davydov et Harvé Leka
//#	Date :	21 décembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"

extern struct noeudVM* head;
extern struct noeudVM* queue;
extern int nbThreadAELX, nbVM;
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

void verrouillerSemaphoresQetH() {
	//verrouiller pointeur de tete et pointeur de queue
	sem_wait(&semH);
   sem_wait(&semQ);
}

void deverrouillerSemaphoresQetH() {
	// deverrouiller pointeur de tete et pointeur de queue
	sem_post(&semQ);
	sem_post(&semH);
}

void decrementerAELX() {
	sem_wait(&semnbThreadAELX);
	nbThreadAELX--;
	sem_post(&semnbThreadAELX);
}

void incrementerAELX() {
	sem_wait(&semnbThreadAELX);
	nbThreadAELX++;
	sem_post(&semnbThreadAELX);
}

void incrementerNbVM() {
	sem_wait(&semnbVM);
	nbVM++;
	sem_post(&semnbVM);
}

void decrementerNbVM(){
	sem_wait(&semnbVM);
	nbVM--;
	sem_post(&semnbVM);
}

struct noeudVM * findItem(const int no){
   verrouillerSemaphoresQetH();
   
	if (head == NULL && queue == NULL) { // Liste est vide
		deverrouillerSemaphoresQetH();
		return NULL;
	}
	
	//verrouiller noeud de tete
	sem_wait(&head->semNoeud); //verrouiller noeud de tete
	struct noeudVM * ptr = head;
	deverrouillerSemaphoresQetH();

	if(ptr->VM.noVM==no) // premier noeudVM
		return ptr; // retourner le noeud de tete verrouille
		
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	} else { // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}

	while (ptr->suivant!=NULL){
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr = ptr->suivant;
		sem_post(&(optr->semNoeud)); 

		//Est-ce l'item recherché?
		if (ptr->VM.noVM==no){
			return ptr; // retourner le noeud verrouille
		}
		
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud));
		} else {
			sem_post(&(ptr->semNoeud)); // deverrouille dernier noeud verrouille
		}
	}
	//On retourne un pointeur NULL
	return NULL;
}

struct noeudVM * findPrev(const int no){
   verrouillerSemaphoresQetH();
   
	if (head == NULL && queue == NULL) {
		deverrouillerSemaphoresQetH();
		return NULL;
	}
	
	sem_wait(&(head->semNoeud)); // verrouiller premier noeud
	
	struct noeudVM * ptr = head;
	deverrouillerSemaphoresQetH();
	
	if(ptr->suivant!=NULL){
		sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
	}
	else{ // ptr->suivant==NULL no invalide
		sem_post(&(ptr->semNoeud)); // deverrouille noeud de tete 
	}
	
	//Tant qu'un item suivant existe
	while (ptr->suivant!=NULL){
		//Est-ce le prédécesseur de l'item recherché?
		if (ptr->suivant->VM.noVM==no){
			//Deverouiller le noeud suivant
			sem_post(&(ptr->suivant->semNoeud));
			
			//On retourne un pointeur sur l'item précédent
			//Retourne le noeud verrouille
			return ptr;
		}
		struct noeudVM* optr = ptr;
		//Déplacement du pointeur de navigation
		ptr=ptr->suivant;
		sem_post(&(optr->semNoeud)); 
		
		if(ptr->suivant!=NULL){
			sem_wait(&(ptr->suivant->semNoeud)); // verrouille noeud suivant de ptr
		}
		else{ // ptr->suivant==NULL no invalide
			sem_post(&(ptr->semNoeud)); // deverrouille noeud courant
		}
	}
	//On retourne un pointeur NULL
	return NULL;
	}

void addItem(struct dataForTransactions * data){
	incrementerAELX();
	
	//Création de l'enregistrement en mémoire
	struct noeudVM* ni = (struct noeudVM*)malloc(sizeof(struct noeudVM));
	incrementerNbVM();
	ni->VM.noVM	= nbVM;
	ni->VM.busy	= 0;
	ni->VM.ptrDebutVM	= (unsigned short*)malloc(sizeof(unsigned short)*65536);

	sem_init(&(ni->semNoeud),0,1); // Semaphore pour le nouveau noeud
	
   verrouillerSemaphoresQetH();
     
	if (head == NULL && queue == NULL){//liste vide
		ni->suivant = NULL;
		queue = head = ni;

		deverrouillerSemaphoresQetH();
		decrementerAELX();

		snprintf(data->response, 100, "VM %d has been added with success.", nbVM);
	  	pthread_exit(0);
	}
	
	sem_wait(&(queue->semNoeud));	// verrouillage du noeud de queue	
	sem_post(&semH);
	
	struct noeudVM* tptr = queue;
	ni->suivant = NULL;
	queue = ni;	
	tptr->suivant = ni;

	sem_post(&(tptr->semNoeud));

	sem_post(&semQ);
	decrementerAELX();

	snprintf(data->response, 100, "VM %d has been added with success.", nbVM);
}

void removeItem(struct dataForTransactions * data){
	int noVM = data->noVM;
	free(data);

	struct noeudVM * ptr;
	struct noeudVM * tptr;
	struct noeudVM * optr;
	
	 // Attendre la terminaison des threads A E L et X  
    while(1) 
    {     
        sem_wait(&semnbThreadAELX);
        
        if(nbThreadAELX == 0)
        {
            break;
        }
        sem_post(&semnbThreadAELX);	
    }	
   
	//Vérification sommaire (noVM>0 et liste non vide)	aucune suppression
	if ( noVM < 1 || ((head==NULL)&&(queue==NULL)) || noVM > nbVM) {
		sem_post(&semnbThreadAELX);
		snprintf(data->response, 100, "No VM to be deleted. Empty list or VM doesn't exist.", nbVM);
		pthread_exit(0);
	}
		
	//Pointeur de recherche
	if(noVM==1){
		ptr = head;
		// suppression du premier element de la liste
		//Le noeud head reste verrouille
	} else {
		ptr = findItem(noVM-1); //Si ptr ! NULL, noeud previous deja verrouille
	}
	
	//L'item a été trouvé
	if (ptr!=NULL){
		sem_post(&(ptr->semNoeud)); // deverrouillage du noeud pas necessaire d'etre verrouille
		decrementerNbVM();

		if((head == ptr) && (noVM==1)) // suppression de l'element de tete
		{
			if(head == queue) // un seul element dans la liste
			{
				sem_destroy(&(ptr->semNoeud));
				free(ptr->VM.ptrDebutVM);
				free(ptr);
				queue = head = NULL;
				
				sem_post(&semnbThreadAELX);
				snprintf(data->response, 100, "VM %d has been deleted with success.", noVM);
				pthread_exit(0);
			}
			tptr = ptr->suivant;
			head = tptr;		
			sem_destroy(&(ptr->semNoeud));
			free(ptr->VM.ptrDebutVM);
			free(ptr);		
		}
		else if (queue==ptr->suivant) // suppression de l'element de queue
		{
			queue = ptr;
			sem_destroy(&(ptr->suivant->semNoeud));
			free(ptr->suivant->VM.ptrDebutVM);
			free(ptr->suivant);
			ptr->suivant=NULL;
						
			sem_post(&semnbThreadAELX);	
			pthread_exit(0);
		} else { // suppression d'un element dans la liste
			optr = ptr->suivant;	// optr pointe sur noeud a supprimer 
			ptr->suivant = ptr->suivant->suivant;
			tptr = ptr->suivant;
			
			sem_destroy(&(optr->semNoeud));	
			free(optr->VM.ptrDebutVM);
			free(optr);		
		}
		
		while (tptr!=NULL){ // ajustement des numeros de VM
			tptr->VM.noVM--;		
			tptr=tptr->suivant;
		}
		sem_post(&semnbThreadAELX);
	}
	else {
		sem_post(&semnbThreadAELX);
	}

	snprintf(data->response, 100, "VM %d has been deleted with success.", noVM);
}

void listItems(struct dataForTransactions * data){
	int start = data->nstart;
	int end = data->nend;
	free(data);

	char response[RESPONSE_SIZE];
	
	incrementerAELX();
   sem_wait(&semC); // Verrouiller la console
   sem_wait(&semH);
	
	strcpy(response, "noVM  Busy? \t Adresse Debut VM");
	strcat(response, "\n========================================================\n");
	strcpy(data->response, response);

	struct noeudVM * ptr = head;
	//Verrouiller le noeud de tete
	if (head != NULL) { sem_wait(&(ptr->semNoeud)); } // Verrouiller le noeud s'il existe
	sem_post(&semH); //Deverrouiller le pointeur de tete

	while (ptr!=NULL){
		//L'item a un numéro séquentiel dans l'interval défini
		if ((ptr->VM.noVM >= start) && (ptr->VM.noVM <= end)){
			snprintf(response, 100, "   %d \t %d \t %p\n", ptr->VM.noVM, ptr->VM.busy, ptr->VM.ptrDebutVM);
			printf("%d", ptr->VM.noVM);
			strcat(data->response, response);
		} else {
			break;		
		}
			
		if (ptr->VM.noVM>end){
			//L'ensemble des items potentiels sont maintenant passés
			//Déplacement immédiatement à la FIN de la liste
			//Notez que le pointeur optr est toujours valide
			ptr=NULL;
			sem_post(&(ptr->semNoeud));
		} else {
			struct noeudVM* optr = ptr;
			if (ptr->suivant!=NULL) {
				sem_wait(&(ptr->suivant->semNoeud));
			}
			ptr = ptr->suivant;
			sem_post(&(optr->semNoeud)); 
		}
	}

	snprintf(response, 100, "%s\n", "========================================================");
	strcat(data->response, response);
	
	// Deverrouiller la console
	sem_post(&semC);	
	decrementerAELX();
}
