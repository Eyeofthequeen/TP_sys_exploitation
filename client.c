
//#########################################################
//#
//# Titre : 	TP3
//#
//# Auteur : 	Miriam Davydov et Harvé Leka
//#	Date :	21 décembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "client.h"
#include <errno.h>
#include <ctype.h>
#include <ncurses.h>
#include <string.h>

void handleColorErrors () {
    if (has_colors() == FALSE)
    {
        endwin();
        printf("Terminal doesn't handle colors... \n");

        exit(EXIT_FAILURE);
    }
}

int main()
{
    struct transaction_info transaction_info;
    struct sockaddr_in address;

    int server_fd, socket_fd, width, height, error_code;
    char response[1000], transaction[MAX_BUFFER_SIZE];

    initscr();
    keypad(stdscr, TRUE);
    scrollok(stdscr, TRUE);

    handleColorErrors();

    start_color();
    init_pair(1, COLOR_CYAN, COLOR_BLACK);

    getmaxyx(stdscr, height, width); // Sets height and width to the actual size of the client screen

    WINDOW *win_receptions = newwin(height - TRANSMISSION_HEIGHT, width, 0, 0);
    scrollok(win_receptions, TRUE);

    WINDOW *win_transmissions = newwin(TRANSMISSION_HEIGHT, width, height - TRANSMISSION_HEIGHT, 0);
    scrollok(win_transmissions, TRUE);

    box(win_transmissions, '|', '-');
    box(win_receptions, '|', '-');

    refresh();

    wrefresh(win_transmissions);
    wrefresh(win_receptions);

    mvwprintw(win_receptions, 1, 2, "RECEPTIONS");
    wrefresh(win_receptions);

    mvwprintw(win_transmissions, 1, 2, "Entrez une commande: ");
    wrefresh(win_transmissions);

    wgetstr(win_transmissions, transaction);

    do
    {
        refresh();

        if (transaction[0] != '\0')
        {
            strcpy(transaction_info.transaction, transaction);

            if (strcmp(QUIT_COMMAND, transaction) == 0)
            {
                break;
            }

            socket_fd = socket(AF_INET, SOCK_STREAM, 0); // socket
            if (socket_fd < 0)
            {
                printf("\n\n Socked creation failed...\n");
            }
            else
            {
            	printf("\n\n Socket successfully created...\n");
            	
                address.sin_family = AF_INET;
                address.sin_addr.s_addr = inet_addr(LOCALHOST);
                address.sin_port = PORT;

                int connect_result = connect(socket_fd, (struct sockaddr *)&address, sizeof(address));

                if (connect_result < 0)
                {
                    error_code = errno;

                    printf("\nÉchec de la connexion au serveur... [error code=%d]\n", error_code);
                }
                else
                {
                    write(socket_fd, &transaction_info.transaction, sizeof(transaction_info.transaction)); // Sends transaction to server

                    if (read(socket_fd, transaction_info.response, sizeof(transaction_info.response)) > 0) // Read serveur response
                    {
                        wclear(win_receptions);
                        wrefresh(win_receptions);

                        mvwprintw(win_receptions, 1, 2, "RECEPTIONS");
                        wattron(win_receptions, COLOR_PAIR(1)); // Add color

                        mvwaddstr(win_receptions, 3, 2, transaction_info.response); // Print response
                        wattroff(win_receptions, COLOR_PAIR(1));

                        box(win_receptions, '|', '-');
                        wrefresh(win_receptions);
                    }
                }
            }
        }

        mvwprintw(win_transmissions, 1, 2, "Entrez une commande: ");
        wrefresh(win_transmissions);

        wclrtobot(win_transmissions);
        box(win_transmissions, '|', '-');

        wrefresh(win_transmissions);

        wgetstr(win_transmissions, transaction);

        wrefresh(win_transmissions);

    } while (strcmp(QUIT_COMMAND, transaction) != 0);

    close(socket_fd);

    endwin();

    delwin(win_transmissions);
    delwin(win_receptions);

    return EXIT_SUCCESS;
}