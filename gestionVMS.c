//#########################################################
//#
//# Titre : 	Utilitaires CVS LINUX Automne 21
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#            VERSION CONCURRENTE
//#
//# Auteur : 	Francois Meunier
//#	Date :		Novembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include "executionFichier.h"
#include "curses.h"

//Pointeur de tête de liste
extern struct noeud* head;
//Pointeur de queue de liste pour ajout rapide
extern struct noeud* queue;

// nombre de VM actives
extern int nbVM;

// nombre de threads actifs
extern int nbThreadAELX;
//Semaphores
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

//#######################################
//#
//# Affiche une série de retour de ligne pour nettoyer la console
//#
void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
	}

//#######################################
//#
//# Affiche un messgae et quitte le programme
//#
void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
	
void generateBackground() {
	char pattern = '.';
	for (int x_loop = 0; x_loop < COLS - 1; x_loop++) {
		for (int y_loop = 0; y_loop < LINES - 1; y_loop++) {
			mvwaddch(stdscr, y_loop, x_loop, pattern);
		}
	}
}
	

void* readTrans(char* nomFichier){
	// Un compteur de thread et une liste de tid
	pthread_t tid[1000];
	int nbThread = 0;
	int i;
	
	//FILE *f;
	char buffer[100];
	char *tok, *sp;
	
	WINDOW *client;
	WINDOW *serveur;
	int WIDTH = 60;
	int HIGHT = 35;

	//Ouverture du fichier en mode "r" (equiv. "rt") : [r]ead [t]ext
	//f = fopen(nomFichier, "rt");
	//if (f==NULL)
//		error(2, "readTrans: Erreur lors de l'ouverture du fichier.");

	//Lecture (tentative) d'une ligne de texte
	//fgets(buffer, 100, f);
	printf("FUCK U");
	
	initscr();
	
	move(5, 5);
	refresh();
	
	generateBackground();
	
	refresh();
	sleep(2);
	
	client = newwin(HIGHT, WIDTH, 0, 0);
	box(client, '|', '=');
	mvwprintw(client, 2, 2, "%s", "Enter transaction:");
	char response[100];
	wgetstr(client, response);
	mvwprintw(client, 10, 2, "%s", response); // affiche la reponse
	
	wrefresh(client);
	sleep(2);

	char * transaction;
	int run = 1;
	//Pour chacune des lignes lues
	while(run){
		sleep(1);

		//Extraction du type de transaction
		//tok = strtok_r(buffer, " ", &sp);
		transaction = strtok(response, " ");

		mvwprintw(client, 20, 2, "%c", transaction[0]);
		wrefresh(client);
		
		//Branchement selon le type de transaction
		switch(transaction[0]){
			case 'A':
			case 'a':{
				// Creer un thread pour addItem (Ajouter une VM)
				pthread_create(&tid[nbThread++], NULL, addItem, NULL);
				break;
				}
			case 'E':
			case 'e':{
				//Extraction du paramètre
				int noVM = atoi(strtok_r(NULL, " ", &sp));

				// Creer un thread pour removeItem (Supprimer une VM)
				
				//Creer une instance de la structure a passer listItems
				struct paramE *ptr = (struct paramE*) malloc(sizeof(struct paramE));
				ptr->noVM = noVM;
				pthread_create(&tid[nbThread++], NULL, removeItem, ptr);
				break;
				}
			case 'L':
			case 'l':{
				//Extraction des paramètres
				int nstart = atoi(strtok_r(NULL, "-", &sp));
				int nend = atoi(strtok_r(NULL, " ", &sp));
				
				//Creer une instance de la structure a passer listItems
				struct paramL *ptr = (struct paramL*) malloc(sizeof(struct paramL));
				ptr->nstart = nstart;
				ptr->nend = nend;
				
				// Creer un thread pour removeItem (Enlever une VM)
				pthread_create(&tid[nbThread++], NULL, listItems, ptr);				
				
				break;
				}
			case 'X':
			case 'x':{
				//Appel de la fonction associée
				int noVM = atoi(strtok_r(NULL, " ", &sp));
				char *nomfich = strtok_r(NULL, "\n", &sp);
				
				//Creer une instance de la structure a passer pthread_create
				struct paramX *ptr = (struct paramX*) malloc(sizeof(struct paramX));
				ptr->noVM = noVM;
				strcpy(ptr->nomfich,(const char *)nomfich);
				
				//Creer un thread pour executer le code binaire du fichier nomFich sur la VM noVM
				pthread_create(&tid[nbThread++], NULL, executerFichier, ptr);
				
				break;
				}
		}
		
		//Lecture (tentative) de la prochaine ligne de texte
		//fgets(buffer, 100, f);
		run = 0;
	}
	
	serveur = newwin(HIGHT, WIDTH, 0, WIDTH + 5);
	box(serveur, '|', '-');
	mvwprintw(serveur, 5, 2, "%s", "Pop up window");
	wrefresh(serveur);
	sleep(2);

	touchwin(client);
	wrefresh(client);
	sleep(2);

	wclear(client);
	wrefresh(client);
	sleep(2);

	delwin(client); // delete window

	touchwin(serveur);
	wrefresh(serveur);
	sleep(2);

	delwin(serveur);

	touchwin(stdscr);
	refresh();
	sleep(2);

	endwin();
	
	//Attendre la fin de tous les transactions
	for(i = 0; i < nbThread; i++) {
		pthread_join(tid[i], NULL);
	}

	//Fermeture du fichier
	//fclose(f);
	//Retour
	return NULL;
}


