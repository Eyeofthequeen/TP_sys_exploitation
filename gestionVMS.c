//#########################################################
//#
//# Titre : 	Utilitaires CVS LINUX Automne 21
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#            VERSION CONCURRENTE
//#
//# Auteur : 	Francois Meunier
//#	Date :		Novembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include "executionFichier.h"
#include "curses.h"

extern struct noeud* head;
extern struct noeud* queue;

extern int nbThreadAELX, nbVM;;
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;


void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
}

void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
void handler(int sig) {
	endwin();
	exit(0);
}

void generateBackground() {
	char pattern = '.';
	for (int x_loop = 0; x_loop < COLS - 1; x_loop++) {
		for (int y_loop = 0; y_loop < LINES - 1; y_loop++) {
			mvwaddch(stdscr, y_loop, x_loop, pattern);
		}
	}
}

void* readTrans(char* nomFichier){
	// Un compteur de thread et une liste de tid
	pthread_t tid[1000];
	int nbThread = 0;
	
	WINDOW *client;
	WINDOW *serveur;
	int WIDTH = 60;
	int HIGHT = 35;
	char response[100];
	char * transaction, * rest;
	int haserror;
	
	initscr();
	
	move(5, 5);
	refresh();
	
	generateBackground();
	
	refresh();
	sleep(2);
	
	client = newwin(HIGHT, WIDTH, 0, 0);
	serveur = newwin(HIGHT, WIDTH, 0, WIDTH + 5);
	
	signal(SIGINT, handler); // Permet le CTRL + C
	while(1) {
		haserror = 0;

		wclear(client);
		box(client, '|', '-');
		mvwprintw(client, 2, 2, "%s", "CLIENT\n  Press 'q' anytime to end the transactions \n\n  Enter transaction: ");
		wgetstr(client, response);
		mvwprintw(client, 10, 2, "%s", response);
	
		if (strchr(response, 'q') != NULL) {
			break;
		}

		wrefresh(client);
		sleep(2);

		transaction = strtok_r(response, " ", &rest); //Extraction du type de transaction	
		switch(toupper(transaction[0])){
			case 'A':{
				struct paramA *ptr = (struct paramA*) malloc(sizeof(struct paramA));
				ptr->serveur = serveur;
				
				pthread_create(&tid[nbThread++], NULL, addItem, ptr);
				break;
			}
			case 'E':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));

				struct paramE *ptr = (struct paramE*) malloc(sizeof(struct paramE));
				ptr->noVM = noVM;
				ptr->serveur = serveur;

				pthread_create(&tid[nbThread++], NULL, removeItem, ptr);
				break;
				}
			case 'L':{
				int nstart = atoi(strtok_r(NULL, "-", &rest));
				int nend = atoi(strtok_r(NULL, " ", &rest));
				
				struct paramL *ptr = (struct paramL*) malloc(sizeof(struct paramL));
				ptr->nstart = nstart;
				ptr->nend = nend;
				ptr->serveur = serveur;
				
				pthread_create(&tid[nbThread++], NULL, listItems, ptr);				
				
				break;
				}
			case 'X':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));
				char *nomfich = strtok_r(NULL, "\n", &rest);
				
				struct paramX *ptr = (struct paramX*) malloc(sizeof(struct paramX));
				ptr->noVM = noVM;
				ptr->serveur = serveur;
				strcpy(ptr->nomfich,(const char *)nomfich);
				
				pthread_create(&tid[nbThread++], NULL, executerFichier, ptr);
				break;
			}
			default: {
				mvwprintw(serveur, 4, 2, "%s", "Transaction failed because of syntax.\n  Please try again.");
				haserror = 1;
			}
		}
	
		if (!haserror) {
			mvwprintw(serveur, 4, 2, "%s", "Transaction in progres...");
			pthread_join(tid[nbThread - 1], NULL);
		}

		box(serveur, '|', '-');
		mvwprintw(serveur, 2, 2, "%s", "SERVEUR");
		wrefresh(serveur);
		wclear(serveur);
		sleep(2);	
	}
	
	mvwprintw(serveur, 2, 2, "%s", "Goodbye!");
	delwin(client); // delete window

	touchwin(serveur);
	wrefresh(serveur);
	sleep(1);

	delwin(serveur);

	touchwin(stdscr);
	refresh();
	sleep(1);

	endwin();
	
	return NULL;
}


