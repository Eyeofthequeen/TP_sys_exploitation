//#########################################################
//#
//# Titre : 	TP3
//#
//# Auteur : 	Miriam Davydov et HarvÃ© Leka
//#	Date :	21 dÃ©cembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include "executionFichier.h"
#include "curses.h"

extern struct noeud* head;
extern struct noeud* queue;

extern int nbThreadAELX, nbVM;;
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

#define SERVER_FIFO_NAME "./tmp/serv_fifo"
#define CLIENT_FIFO_NAME "./tmp/cli_%d_fifo"
#define BUFFER_SIZE 20

char client_fifo[100];

void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
}

void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
void handler(int sig) {
	exit(0);
}

const char* readTrans(char* raw_transaction){
	// Un compteur de thread et une liste de tid
	pthread_t tid[1000];
	int nbThread = 0;

	char * transaction, * rest;
	int haserror;
	
	struct dataForTransactions *data_ptr = (struct dataForTransactions*) malloc(sizeof(struct dataForTransactions));
    
		haserror = 0;

		transaction = strtok_r(raw_transaction, " ", &rest); // Extraction du type de transaction	
		switch(toupper(transaction[0])){
			case 'A':{
				pthread_create(&tid[nbThread++], NULL, addItem, data_ptr);
				break;
			}
			case 'E':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));
				data_ptr->noVM = noVM;

				pthread_create(&tid[nbThread++], NULL, removeItem, data_ptr);
				break;
				}
			case 'L':{
				int nstart = atoi(strtok_r(NULL, "-", &rest));
				int nend = atoi(strtok_r(NULL, " ", &rest));
				
				data_ptr->nstart = nstart;
				data_ptr->nend = nend;
				
				pthread_create(&tid[nbThread++], NULL, listItems, data_ptr);				
				break;
				}
			case 'X':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));
				char *nomfich = strtok_r(NULL, "\n", &rest);
				
				data_ptr->noVM = noVM;
				strcpy(data_ptr->nomfich,(const char *)nomfich);
				
				pthread_create(&tid[nbThread++], NULL, executerFichier, data_ptr);
				break;
			}
			default: {
				strcpy(data_ptr->response, "Transaction failed because of syntax.\n  Please try again.");
				haserror = 1;
			}
		}
	
		if (!haserror) {
			pthread_join(tid[nbThread - 1], NULL);
		}
		
		return data_ptr->response;
}

