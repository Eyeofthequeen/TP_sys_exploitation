//#########################################################
//#
//# Titre : 	Utilitaires CVS LINUX Automne 21
//#				SIF-1015 - Système d'exploitation
//#				Université du Québec à Trois-Rivières
//#            VERSION CONCURRENTE
//#
//# Auteur : 	Francois Meunier
//#	Date :		Novembre 2021
//#
//# Langage : 	ANSI C on LINUX 
//#
//#######################################

#include "gestionListeChaineeVMS.h"
#include "gestionVMS.h"
#include "executionFichier.h"
#include "curses.h"

extern struct noeud* head;
extern struct noeud* queue;

extern int nbThreadAELX, nbVM;;
extern sem_t semH, semQ, semnbVM, semC, semnbThreadAELX;

#define SERVER_FIFO_NAME "./tmp/serv_fifo"
#define CLIENT_FIFO_NAME "./tmp/cli_%d_fifo"
#define BUFFER_SIZE 20

char client_fifo[100];

void cls(void){
	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
}

void error(const int exitcode, const char * message){
	printf("\n-------------------------\n%s\n",message);
	exit(exitcode);
	}
	
void handler(int sig) {
	endwin();
	exit(0);
}

void generateBackground() {
	char pattern = '.';
	for (int x_loop = 0; x_loop < COLS - 1; x_loop++) {
		for (int y_loop = 0; y_loop < LINES - 1; y_loop++) {
			mvwaddch(stdscr, y_loop, x_loop, pattern);
		}
	}
}

void initColor(WINDOW* window, const char* text_char, int commandLine)
{
	if (has_colors() == FALSE)
	{
		endwin();
		printf("Error not supported color\n");
		exit(1);
	}

	int color = 1;
	for (int i = 1; i < strlen(text_char) + 1; ++i) {
		if (color > 4)
		{
			color = 1;
		}
		wattron(window, COLOR_PAIR(color));
		mvwprintw(window, commandLine, 13 + i, "%c", text_char[i - 1]);
		wattroff(window, COLOR_PAIR(color));
		color += 1;
		}
}

void* readTrans(char* nomFichier){
	// Un compteur de thread et une liste de tid
	pthread_t tid[1000];
	int nbThread = 0;
	
	WINDOW *client;
	WINDOW *serveur;
	int WIDTH = 60;
	int HIGHT = 35;
	char * transaction, * rest;
	int haserror;
   int res;
   
	initscr();
	
	init_pair(1, COLOR_RED, COLOR_BLACK);
	init_pair(2, COLOR_RED, COLOR_GREEN);
	init_pair(3, COLOR_GREEN, COLOR_RED);
	init_pair(4, COLOR_YELLOW, COLOR_BLUE);

	move(5, 5);
	refresh();
	
	generateBackground();
	
	refresh();
	sleep(2);
	
	client = newwin(HIGHT, WIDTH, 0, 0);
	serveur = newwin(HIGHT, WIDTH, 0, WIDTH + 5);
	
	struct Info_FIFO_Transaction 	fifotransaction;
	int server_fifo_fd, client_fifo_fd;
	char  client_fifo[100];
	
	signal(SIGINT, handler); // Permet le CTRL + C
    
    if (access(SERVER_FIFO_NAME, F_OK) == -1) {        res = mkfifo(SERVER_FIFO_NAME, 0777);        if (res != 0) {            fprintf(stderr, "Could not create fifo %s\n", SERVER_FIFO_NAME);            exit(EXIT_FAILURE);        }        fprintf(stderr, "FIFO created. \n");    }
    
	server_fifo_fd = open(SERVER_FIFO_NAME, O_RDWR);
	if (server_fifo_fd == -1) {
		fprintf(stderr, "Sorry no server \n");
		endwin();
		exit(EXIT_FAILURE);
	}
	
	fifotransaction.pid_client = getpid();
	sprintf(client_fifo, CLIENT_FIFO_NAME, fifotransaction.pid_client);
	if (mkfifo(client_fifo, 0777) == -1) {
   	fprintf(stderr, "Sorry, can't make %s\n", client_fifo);
      exit(EXIT_FAILURE);
   }
   
	while(1) {
		haserror = 0;

		wclear(client);
		box(client, '|', '-');
		mvwprintw(client, 2, 2, "%s", "CLIENT\n  Press 'q' anytime to end the transactions \n\n  Enter transaction: ");
		wgetstr(client, fifotransaction.transaction);

		//write(server_fifo_fd, &fifotransaction.transaction, sizeof(fifotransaction.transaction));
		mvwprintw(client, 10, 2, "%s", fifotransaction.transaction);

		if (strchr(fifotransaction.transaction, 'q') != NULL) {
			break;
		}

		wrefresh(client);
		sleep(2);

		transaction = strtok_r(fifotransaction.transaction, " ", &rest); //Extraction du type de transaction	
		switch(toupper(transaction[0])){
			case 'A':{
				struct paramA *ptr = (struct paramA*) malloc(sizeof(struct paramA));
				ptr->serveur = serveur;
				
				pthread_create(&tid[nbThread++], NULL, addItem, ptr);
				break;
			}
			case 'E':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));

				struct paramE *ptr = (struct paramE*) malloc(sizeof(struct paramE));
				ptr->noVM = noVM;
				ptr->serveur = serveur;

				pthread_create(&tid[nbThread++], NULL, removeItem, ptr);
				break;
				}
			case 'L':{
				int nstart = atoi(strtok_r(NULL, "-", &rest));
				int nend = atoi(strtok_r(NULL, " ", &rest));
				
				struct paramL *ptr = (struct paramL*) malloc(sizeof(struct paramL));
				ptr->nstart = nstart;
				ptr->nend = nend;
				ptr->serveur = serveur;
				
				pthread_create(&tid[nbThread++], NULL, listItems, ptr);				
				
				break;
				}
			case 'X':{
				int noVM = atoi(strtok_r(NULL, " ", &rest));
				char *nomfich = strtok_r(NULL, "\n", &rest);
				
				struct paramX *ptr = (struct paramX*) malloc(sizeof(struct paramX));
				ptr->noVM = noVM;
				ptr->serveur = serveur;
				strcpy(ptr->nomfich,(const char *)nomfich);
				
				pthread_create(&tid[nbThread++], NULL, executerFichier, ptr);
				break;
			}
			default: {
				mvwprintw(serveur, 4, 2, "%s", "Transaction failed because of syntax.\n  Please try again.");
				haserror = 1;
			}
		}
	
		if (!haserror) {
			mvwprintw(serveur, 4, 2, "%s", "Transaction in progres...");
			pthread_join(tid[nbThread - 1], NULL);
		}
		
		//if (read(server_fifo_fd, &my_data, sizeof(fifotransaction.transaction) > 0) {
	//		printf("received: %s\n", fifotransaction.transaction);
		//}

		box(serveur, '|', '-');
		mvwprintw(serveur, 2, 2, "%s", "SERVEUR");
		wrefresh(serveur);
		wclear(serveur);
		sleep(2);	
	}

	mvwprintw(serveur, 2, 2, "%s", "Goodbye!");
	delwin(client); // delete window

	touchwin(serveur);
	wrefresh(serveur);
	sleep(1);

	delwin(serveur);

	touchwin(stdscr);
	refresh();
	sleep(1);

	endwin();
	
	close(server_fifo_fd);
	unlink(client_fifo);
	
	return NULL;
}

